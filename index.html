<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Master Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
    <style>
        body {
            font-family: 'Fira Code', monospace;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        .vim-editor {
            white-space: pre;
            line-height: 1.5;
            caret-color: transparent;
        }
        .line-number {
            color: #858585;
            text-align: right;
            padding-right: 1rem;
            user-select: none;
        }
        .cursor {
            background-color: #f2c55c;
            color: #1e1e1e;
            animation: blink 1s step-end infinite;
            border-radius: 2px;
        }
        @keyframes blink {
            50% {
                background-color: transparent;
                outline: 1px solid #f2c55c;
                color: inherit;
            }
        }
        .status-bar {
            font-weight: 700;
        }
        .modal-bg {
            background-color: rgba(0,0,0,0.7);
            transition: opacity 0.3s ease;
        }
        .modal-content {
            transition: transform 0.3s ease;
        }
        .level-complete-flash {
            animation: flash 0.5s ease-out;
        }
        @keyframes flash {
            0% { box-shadow: 0 0 0 0 rgba(242, 197, 92, 0.7); }
            100% { box-shadow: 0 0 0 20px rgba(242, 197, 92, 0); }
        }
        .ascii-logo {
            line-height: 1.2;
        }
        /* Celebration styles */
        .celebration-bg { background: radial-gradient( circle at center, rgba(34,197,94,0.2), rgba(30,58,138,0.85) ); }
        .celebration-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.72); backdrop-filter: blur(3px); }
        .celebration-text {
            animation: pop 1s ease-out forwards, glow 2.5s ease-in-out infinite alternate;
        }
        @keyframes pop { 0% { transform: scale(0.8); opacity: 0 } 100% { transform: scale(1); opacity: 1 } }
        @keyframes glow { 0% { text-shadow: 0 0 10px rgba(250,204,21,.6) } 100% { text-shadow: 0 0 30px rgba(250,204,21,1) } }
        .confetti { position: fixed; top: -10px; font-size: 18px; animation: fall linear forwards; pointer-events: none; }
        @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity: .9 } }
        /* Badges */
        .badge-card { box-shadow: 0 6px 18px rgba(30, 64, 175, 0.25); }
        .badge-card:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(30, 64, 175, 0.4); }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <pre class="text-yellow-400 text-center text-sm md:text-base ascii-logo">
            _________ _______    _______  _______  _______ _________ _______  _______ 
|\     /|\__   __/(       )  (       )(  ___  )(  ____ \\__   __/(  ____ \(  ____ )
| )   ( |   ) (   | () () |  | () () || (   ) || (    \/   ) (   | (    \/| (    )|
| |   | |   | |   | || || |  | || || || (___) || (_____    | |   | (__    | (____)|
( (   ) )   | |   | |(_)| |  | |(_)| ||  ___  |(_____  )   | |   |  __)   |     __)
 \ \_/ /    | |   | |   | |  | |   | || (   ) |      ) |   | |   | (      | (\ (   
  \   /  ___) (___| )   ( |  | )   ( || )   ( |/\____) |   | |   | (____/\| ) \ \__
   \_/   \_______/|/     \|  |/     \||/     \|\_______)   )_(   (_______/|/   \__/
                                                                                   
        </pre>
        <h1 class="text-3xl font-bold text-center mb-4 text-gray-200">VIM Master</h1>
        <p id="instructions" class="text-lg text-center mb-6 text-gray-400">Welcome! Let's learn VIM.</p>

        <!-- Challenge Mode Toggle -->
        <div class="flex justify-center mb-6">
            <button id="challenge-toggle" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">
                üöÄ Challenge Mode
            </button>
        </div>

        <!-- Challenge Mode Container -->
        <div id="challenge-container" class="hidden mb-6">
            <div class="bg-blue-900 rounded-lg p-4 border border-blue-700">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-blue-200">Speed Challenge</h3>
                    <div class="text-right">
                        <div class="text-2xl font-mono text-yellow-400" id="timer">00:30</div>
                        <div class="text-sm text-blue-300">Time Remaining</div>
                    </div>
                </div>
                <div id="challenge-instructions" class="text-blue-200 mb-4">
                    Complete the challenge as fast as possible!
                </div>
                <div class="flex justify-between items-center">
                    <div class="text-blue-200">
                        <span id="challenge-progress">0</span>/<span id="challenge-total">3</span> completed
                    </div>
                    <div class="text-blue-200">
                        Score: <span id="challenge-score" class="text-yellow-400">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Achievements / Badges -->
        <div id="badge-section" class="mb-4 hidden">
            <div class="flex items-center justify-center gap-2 mb-2">
                <span class="text-yellow-400 text-lg font-extrabold">üèÜ Achievements</span>
                <span id="badge-count" class="text-blue-300 text-sm"></span>
            </div>
            <div id="badge-bar" class="flex justify-center gap-3 flex-wrap"></div>
        </div>

        <div id="editor-container" class="bg-[#1e1e1e] rounded-lg shadow-2xl p-4 border border-gray-700 relative">
            <div id="vim-editor-display" class="vim-editor text-lg"></div>
            <textarea id="vim-editor-input" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-default" spellcheck="false"></textarea>
            <div class="flex justify-between items-center mt-4">
                <div id="status-bar" class="status-bar px-2 py-1 bg-yellow-400 text-gray-900 rounded-md text-sm uppercase">-- NORMAL --</div>
                <div id="command-log" class="text-gray-500 text-sm font-semibold"></div>
            </div>
        </div>

        <div class="flex justify-center items-center mt-4 space-x-4">
            <div id="level-indicator" class="text-gray-500 font-semibold"></div>
            <button id="reset-btn" class="bg-gray-700 text-gray-300 hover:bg-gray-600 font-bold py-1 px-3 rounded-lg transition-colors text-sm">Reset Level</button>
        </div>
        <div id="level-selection" class="flex justify-center flex-wrap gap-2 mt-4">
            <!-- Level selection buttons will be injected here -->
        </div>
    </div>

    <!-- Modal for level completion -->
    <div id="modal" class="fixed inset-0 flex items-center justify-center modal-bg opacity-0 pointer-events-none">
        <div id="modal-content" class="bg-gray-800 text-white p-8 rounded-lg shadow-xl max-w-sm text-center transform scale-95">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Level Complete!</h2>
            <p id="modal-message" class="mb-6">Great job! You've mastered the basics of movement.</p>
            <button id="next-level-btn" class="bg-yellow-400 text-gray-900 font-bold py-2 px-6 rounded-lg hover:bg-yellow-500 transition-colors">Next Level</button>
        </div>
    </div>

    <!-- Celebration Overlay -->
    <div id="celebration" class="fixed inset-0 hidden celebration-bg z-50 flex items-center justify-center w-screen h-screen">
        <div class="celebration-overlay"></div>
        <div class="text-center px-6 relative z-10">
            <div class="text-4xl md:text-6xl font-extrabold text-yellow-300 celebration-text mb-4">COOL! üéâ</div>
            <div class="text-xl md:text-2xl text-blue-100 mb-6">You mastered the Vim basics ‚Äî you're faster now!</div>
            <button id="celebration-restart" class="bg-yellow-400 text-gray-900 font-bold py-2 px-6 rounded-lg hover:bg-yellow-500 transition-colors">Play Again</button>
        </div>
    </div>
    <!-- Badge Toast -->
    <div id="badge-toast" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-yellow-400 text-gray-900 font-bold py-2 px-4 rounded-md shadow-lg hidden z-50"></div>

    <!-- Cheat Mode Panel -->
    <div id="cheat-overlay" class="fixed inset-0 hidden z-40 bg-black/60"></div>
    <div id="cheat-panel" class="fixed right-0 top-0 h-full w-full max-w-xl bg-gray-800 border-l border-gray-700 shadow-2xl transform translate-x-full transition-transform z-50 overflow-y-auto">
        <div class="sticky top-0 bg-gray-800 border-b border-gray-700 p-4 flex items-center gap-3">
            <h3 class="text-xl font-bold text-yellow-400">Cheat Mode</h3>
            <input id="cheat-search" type="text" placeholder="Search commands... (Ctrl+/)" class="flex-1 bg-gray-900 text-gray-100 rounded-md px-3 py-2 border border-gray-700 focus:outline-none focus:border-yellow-400" />
            <button id="cheat-close" class="bg-gray-700 hover:bg-gray-600 text-gray-200 font-bold px-3 py-2 rounded-md">Close</button>
        </div>
        <div id="cheat-content" class="p-4 space-y-6"></div>
    </div>

    <script>
        // DOM Elements
        const editorDisplay = document.getElementById('vim-editor-display');
        const editorInput = document.getElementById('vim-editor-input');
        const statusBar = document.getElementById('status-bar');
        const instructionsEl = document.getElementById('instructions');
        const levelIndicator = document.getElementById('level-indicator');
        const commandLogEl = document.getElementById('command-log');
        const editorContainer = document.getElementById('editor-container');
        const resetBtn = document.getElementById('reset-btn');
        const modal = document.getElementById('modal');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const celebration = document.getElementById('celebration');
        const celebrationRestartBtn = document.getElementById('celebration-restart');
        const levelSelectionContainer = document.getElementById('level-selection');
        const challengeToggleBtn = document.getElementById('challenge-toggle');
        const challengeContainer = document.getElementById('challenge-container');
        const challengeInstructions = document.getElementById('challenge-instructions');
        const challengeTimer = document.getElementById('timer');
        const challengeProgress = document.getElementById('challenge-progress');
        const challengeTotal = document.getElementById('challenge-total');
        const challengeScore = document.getElementById('challenge-score');
        const badgeSection = document.getElementById('badge-section');
        const badgeBar = document.getElementById('badge-bar');
        const badgeCount = document.getElementById('badge-count');
        const badgeToast = document.getElementById('badge-toast');
        const cheatPanel = document.getElementById('cheat-panel');
        const cheatOverlay = document.getElementById('cheat-overlay');
        const cheatCloseBtn = document.getElementById('cheat-close');
        const cheatSearch = document.getElementById('cheat-search');
        const cheatContent = document.getElementById('cheat-content');

        // Game State
        let content = [];
        let cursor = { row: 0, col: 0 };
        let mode = 'NORMAL';
        let currentLevel = 0;
        let commandHistory = '';
        let commandLog = [];
        let yankedLine = null;
        let replacePending = false;
        let countBuffer = '';
        let undoStack = [];
        let redoStack = [];
        let level12Undo = false;
        let level12RedoAfterUndo = false;
        let cheatModeOtherUndo = false;
        let cheatModeOtherRedoAfterUndo = false;
        let lastExCommand = null;
        let searchMode = false;
        let searchQuery = '';
        let lastSearchQuery = null;
        let lastSearchDirection = 'forward'; // 'forward' | 'backward'
        let searchMatches = []; // { row, start, end }
        let currentMatchIndex = -1;
        let usedSearchInLevel = false;
        let navCountSinceSearch = 0;
        let badges = new Set();
        let practicedCommands = new Set();

        // Challenge Mode State
        let challengeMode = false;
        let currentChallenge = null;
        let challengeTimerInterval = null;
        let challengeStartTime = null;
        let challengeScoreValue = 0;
        let challengeProgressValue = 0;
        let currentTaskIndex = 0;

        // Challenge Definitions
        const challenges = [
            {
                name: "Speed Navigation",
                description: "Navigate to the target using the fastest route!",
                timeLimit: 30,
                tasks: [
                    {
                        instruction: "Move to the word 'target' using 3w",
                        validation: () => cursor.row === 0 && cursor.col === 14,
                        hint: "Use 3w to jump 3 words forward"
                    },
                    {
                        instruction: "Jump to the end of the line with $",
                        validation: () => cursor.col === 23,
                        hint: "Use $ to jump to end of line"
                    },
                    {
                        instruction: "Go to the first line with gg",
                        validation: () => cursor.row === 0 && cursor.col === 0,
                        hint: "Use gg to jump to first line"
                    }
                ],
                initialContent: [
                    "one two three target here at end",
                    "second line for practice"
                ]
            },
            {
                name: "Quick Deletion",
                description: "Delete and modify text rapidly!",
                timeLimit: 45,
                tasks: [
                    {
                        instruction: "Position cursor on 'r' of 'remove' and delete the word with dw",
                        validation: () => content[0].includes("delete this line") && !content[0].includes("remove"),
                        hint: "Use h/l to move to 'r' of 'remove', then dw"
                    },
                    {
                        instruction: "Go to second line and delete the entire line with dd",
                        validation: () => content.length === 2,
                        hint: "Use j to go down, then dd to delete line"
                    },
                    {
                        instruction: "Go to third line, position cursor on 'B' of 'BAD' and change to 'GOOD' with cw",
                        validation: () => content[1].includes("GOOD") && !content[1].includes("BAD"),
                        hint: "Use j to go down, position cursor on 'B', use cw then type 'GOOD'"
                    }
                ],
                initialContent: [
                    "delete this remove line",
                    "delete this line too",
                    "This is BAD text"
                ]
            },
            {
                name: "Advanced Moves",
                description: "Master complex command combinations!",
                timeLimit: 60,
                tasks: [
                    {
                        instruction: "Yank the first line 'first line to copy' with yy",
                        validation: () => yankedLine === "first line to copy",
                        hint: "Use yy to yank the current line"
                    },
                    {
                        instruction: "Go to the third line (empty line) and paste with p",
                        validation: () => content.length === 4 && content[3] === "first line to copy",
                        hint: "Use j to go down 2 lines, then p to paste"
                    },
                    {
                        instruction: "Go to second line, position cursor on 'x' and replace with '!' using r",
                        validation: () => content[1].includes("!") && !content[1].includes("x"),
                        hint: "Use k to go up, position cursor on 'x', use r then !"
                    }
                ],
                initialContent: [
                    "first line to copy",
                    "replace this x",
                    ""
                ]
            }
        ];

        const cloneState = () => ({
            content: [...content],
            cursor: { row: cursor.row, col: cursor.col },
            mode,
            yankedLine
        });
        const pushUndo = () => {
            undoStack.push(cloneState());
            if (undoStack.length > 200) undoStack.shift();
            redoStack = [];
        };

        // Utils
        const escapeHtml = (s) => s
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

        // Treat Ctrl-[ as Escape (common Vim alias). Avoid Shift/Alt/Meta to not clash with other combos
        const isEscapeKey = (e) => e.key === 'Escape' || (e.key === '[' && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey);

        const levels = [
            // Level 1: Exiting Vim (fun intro)
            {
                name: "How to Exit (Ex Commands)",
                instructions: "Type :q to quit, or :wq to write and quit. Press Enter after the command.",
                initialContent: [
                    "Welcome to VIM Master!",
                    "Most searched question: how to exit Vim?",
                    "Try typing :q and press Enter (or :wq)."
                ],
                exCommands: ["q", "wq"],
                setup: () => { cursor = { row: 0, col: 0 }; commandHistory = ''; }
            },
            // Level 1: Basic Movement
            {
                name: "Basic Movement",
                instructions: "Use h, j, k, l to move the cursor. Reach the target character '$'.",
                initialContent: [
                    "Move with h(left), j(down), k(up), l(right).",
                    "Your cursor starts here.",
                    "",
                    "The goal is to navigate to the dollar sign.",
                    "Practice moving around the text.",
                    "Once you are comfortable, move to the '$'."
                ],
                target: { row: 5, col: 39 },
                setup: () => { cursor = { row: 1, col: 5 }; }
            },
            // Level 2: Word Movement
            {
                name: "Word Movement",
                instructions: "Use w (next word), b (back), e (end of word). Get to the end of the 'destination' word.",
                initialContent: [
                    "Jumping between words is much faster.",
                    "Use 'w' to jump forwards to the start of the next word.",
                    "Use 'b' to jump backwards to the start of the previous word.",
                    "Use 'e' to jump to the end of the current word.",
                    "Find the ultimate destination."
                ],
                target: { row: 4, col: 28 }, // Target is the 'n' in destination
                setup: () => { cursor = { row: 0, col: 0 }; }
            },
            // Level 3: Line Jumps
            {
                name: "Line Jumps",
                instructions: "Use gg to go to the first line, and G to go to the last line. Go to the last character of the last line.",
                initialContent: [
                    "This is the first line. Use 'gg' to come here.",
                    "...",
                    "...",
                    "...",
                    "This is the last line. Use 'G' to jump here.",
                    "The target is on the word 'here'."
                ],
                target: { row: 5, col: 32 }, // Target is the '.' at the end of the line
                setup: () => { cursor = { row: 2, col: 0 }; commandHistory = ''; }
            },
            // Level 4: Insert Mode
            {
                name: "Insert Mode",
                instructions: "Press 'a' to append after the cursor. Type ' is awesome!' and press Esc to return to NORMAL mode.",
                initialContent: [
                    "VIM has multiple modes. You've been in NORMAL mode.",
                    "Press 'a' to append after the cursor and start typing.",
                    "When you're done, press 'Escape' to go back.",
                    "Your task: complete the sentence below.",
                    "Learning VIM"
                ],
                targetText: { line: 4, text: "Learning VIM is awesome!" },
                setup: () => { cursor = { row: 4, col: 11 }; }
            },
             // Level 5: Delete Basics
            {
                name: "Delete Basics",
                instructions: "Use dd to delete the full middle line. Then use dw to remove the word 'mistake' on the last line. You can use x to delete a single character if needed.",
                initialContent: [
                    "Keep this line.",
                    "Delete this entire line.",
                    "Fix this mistake here."
                ],
                targetContent: [
                    "Keep this line.",
                    "Fix this here."
                ],
                setup: () => { cursor = { row: 0, col: 0 }; commandHistory = ''; }
            },
            // Level 6: Yank & Put
            {
                name: "Yank & Put (Copy/Paste)",
                instructions: "Use yy to yank (copy) a line and p to put (paste) it. Duplicate the second line.",
                initialContent: [
                    "Let's copy and paste.",
                    "Yank this line!",
                    "And put it below this line.",
                    ""
                ],
                targetContent: [
                    "Let's copy and paste.",
                    "Yank this line!",
                    "And put it below this line.",
                    "Yank this line!",
                ],
                setup: () => { cursor = { row: 1, col: 0 }; commandHistory = ''; }
            },
            // Level 7: Line Start/End
            {
                name: "Line Bounds (0 and $)",
                instructions: "Use 0 to jump to start of line and $ to jump to end. Move to the last character of the first line.",
                initialContent: [
                    "Jump to the start and end of this line.",
                    "Practice makes perfect."
                ],
                // The first line length is 39, last character index is length - 1 = 38
                target: { row: 0, col: 38 },
                setup: () => { cursor = { row: 0, col: 0 }; }
            },
            // Level 8: Append and Open Lines
            {
                name: "Append and Open Lines",
                instructions: "Use a to append after cursor. Use o to open a new line below, and O to open above. Add a new line between the two lines that reads 'Inserted here'.",
                initialContent: [
                    "First line.",
                    "Second line."
                ],
                targetContent: [
                    "First line.",
                    "Inserted here",
                    "Second line."
                ],
                setup: () => { cursor = { row: 0, col: 5 }; }
            },
            // Level 9: Change Word (cw)
            {
                name: "Change Word (cw)",
                instructions: "Use cw to change the word 'bad' into 'good'. Press Esc when done.",
                initialContent: [
                    "This is a bad example."
                ],
                targetText: { line: 0, text: "This is a good example." },
                setup: () => { cursor = { row: 0, col: 10 }; }
            },
            // Level 10: Delete to End (D) and Replace (r)
            {
                name: "Delete End & Replace",
                instructions: "Use D to delete from cursor to end of line, then use r to replace the 'x' with '!'.",
                initialContent: [
                    "Keep this ‚Üí remove from here to end",
                    "Replace this x"
                ],
                targetContent: [
                    "Keep this ‚Üí ",
                    "Replace this !"
                ],
                setup: () => { cursor = { row: 0, col: 12 }; }
            },
            // Level 11: Numeric Counts (3w)
            {
                name: "Counts: Move Faster",
                instructions: "Use a count with motions. Press 3 then w to jump three words and land on 'target'.",
                initialContent: [
                    "one two three target here"
                ],
                target: { row: 0, col: 14 },
                setup: () => { cursor = { row: 0, col: 0 }; }
            },
            // Level 12: Undo and Redo
            {
                name: "Undo / Redo",
                instructions: "Delete the middle line with dd, undo it with u, then redo with Ctrl+r to finish with the line deleted.",
                initialContent: [
                    "Top line.",
                    "Remove me.",
                    "Bottom line."
                ],
                targetContent: [
                    "Top line.",
                    "Bottom line."
                ],
                setup: () => { cursor = { row: 1, col: 0 }; }
            }
            ,
            // Level 13: Forward Search
            {
                name: "Search Forward (/)",
                instructions: "Press / then type 'target' and Enter, then press n once to jump to the next occurrence.",
                initialContent: [
                    "find the target here",
                    "another target and another target",
                    "no match on this line"
                ],
                // second 'target' on line 2 (index 27)
                target: { row: 1, col: 27 },
                setup: () => { cursor = { row: 2, col: 0 }; }
            }
            ,
            // Level 14: Backward Search
            {
                name: "Search Backward (?)",
                instructions: "Press ? then type 'alpha' and Enter, then press N once to jump to the previous occurrence.",
                initialContent: [
                    "alpha beta gamma",
                    "delta epsilon alpha",
                    "zeta eta theta"
                ],
                // require moving to the earlier 'alpha' on line 1 (row 0, col 0) using N
                target: { row: 0, col: 0 },
                setup: () => { cursor = { row: 2, col: 5 }; }
            }
            ,
            // Level 15: Search Navigation (n/N)
            {
                name: "Search Navigation (n/N)",
                instructions: "Search for 'foo' with /foo then press n twice to reach the third occurrence.",
                initialContent: [
                    "foo bar baz",
                    "qux foo quux",
                    "corge grault foo"
                ],
                // third 'foo' starts at col 13 in line 2 (0-based)
                target: { row: 2, col: 13 },
                setup: () => { cursor = { row: 0, col: 0 }; }
            }
        ];

        // --- RENDER FUNCTIONS ---
        function renderEditor() {
            let html = '';
            const isInMatch = (row, col) => {
                for (let i = 0; i < searchMatches.length; i++) {
                    const m = searchMatches[i];
                    if (m.row === row && col >= m.start && col < m.end) return true;
                }
                return false;
            };
            content.forEach((line, rowIndex) => {
                html += `<div class="flex"><span class="line-number w-10">${rowIndex + 1}</span><span class="flex-1">`;
                for (let colIndex = 0; colIndex < line.length; colIndex++) {
                    const char = line[colIndex];
                    const safeChar = escapeHtml(char);
                    if (rowIndex === cursor.row && colIndex === cursor.col && mode === 'NORMAL') {
                        html += `<span class="cursor">${safeChar}</span>`;
                    } else {
                        if (lastSearchQuery && isInMatch(rowIndex, colIndex)) {
                            html += `<span class="bg-yellow-800/60">${safeChar}</span>`;
                        } else {
                            html += safeChar;
                        }
                    }
                }
                if (rowIndex === cursor.row && (cursor.col === line.length || line.length === 0)) {
                     if (mode === 'NORMAL') {
                        html += `<span class="cursor">&nbsp;</span>`;
                     } else {
                        html += `<span class="inline-block w-px h-6 bg-yellow-400 animate-pulse -mb-1"></span>`;
                     }
                }
                html += `</span></div>`;
            });
            editorDisplay.innerHTML = html;
        }

        function updateStatusBar() {
            let text = `-- ${mode.toUpperCase()} --`;
            if (searchMode) {
                const prefix = lastSearchDirection === 'backward' ? '?' : '/';
                text += ` ${prefix}${searchQuery}`;
            } else if (lastSearchQuery) {
                const total = searchMatches.length;
                const current = currentMatchIndex >= 0 ? currentMatchIndex + 1 : 0;
                const dir = lastSearchDirection === 'backward' ? '?' : '/';
                text += ` ${dir}${lastSearchQuery} ${current}/${total}`;
            }
            statusBar.textContent = text;
            statusBar.className = `status-bar px-2 py-1 rounded-md text-sm ${mode === 'NORMAL' ? 'bg-yellow-400 text-gray-900' : 'bg-green-400 text-gray-900'}`;
        }

        // --- BADGES ---
        function renderBadges() {
            badgeBar.innerHTML = '';
            const badgeDefs = {
                beginner: { label: 'Beginner', emoji: 'üü¢', title: 'Completed basic movement lessons' },
                searchmaster: { label: 'Search Master', emoji: 'üîé', title: 'Used / ? n N to search' }
            };
            const earned = Array.from(badges);
            if (earned.length === 0) {
                badgeSection.classList.add('hidden');
                return;
            }
            badgeSection.classList.remove('hidden');
            badgeCount.textContent = `(${earned.length} earned)`;
            earned.forEach((key) => {
                const def = badgeDefs[key];
                if (!def) return;
                const el = document.createElement('div');
                el.className = 'badge-card bg-blue-900/70 border border-blue-700 text-blue-100 px-4 py-2 rounded-lg text-sm flex items-center gap-2 transition-transform';
                el.title = def.title;
                el.innerHTML = `<span>${def.emoji}</span><span>${def.label}</span>`;
                badgeBar.appendChild(el);
            });
        }

        // --- CHEAT MODE ---
        const commandCatalog = [
            {
                category: 'Movement',
                items: [
                    { key: 'h / j / k / l', id: 'hjkL', desc: 'Move left/down/up/right', example: 'Navigate the cursor around the text.' },
                    { key: 'w / b / e', id: 'wbe', desc: 'Word motions: next/back/end', example: 'Jump between words quickly.' },
                    { key: 'gg / G', id: 'ggG', desc: 'Go to first/last line', example: 'Jump to file bounds.' },
                    { key: '0 / $', id: '0$', desc: 'Line start / end', example: 'Move to start or end of line.' },
                ]
            },
            {
                category: 'Editing',
                items: [
                    { key: 'i / a', id: 'ia', desc: 'Insert/Append text', example: 'Enter insert mode to type.' },
                    { key: 'x', id: 'x', desc: 'Delete character', example: 'Remove a single character.' },
                    { key: 'dd', id: 'dd', desc: 'Delete line', example: 'Remove an entire line.' },
                    { key: 'dw', id: 'dw', desc: 'Delete word', example: 'Remove word from cursor.' },
                    { key: 'yy / p', id: 'yyp', desc: 'Yank and paste line', example: 'Copy and paste a line.' },
                    { key: 'cw', id: 'cw', desc: 'Change word', example: 'Delete word and enter insert.' },
                    { key: 'D', id: 'D', desc: 'Delete to end of line', example: 'Trim line from cursor to end.' },
                    { key: 'r', id: 'r', desc: 'Replace one character', example: 'Replace character under cursor.' },
                ]
            },
            {
                category: 'Search',
                items: [
                    { key: '/text', id: 'search-forward', desc: 'Search forward for text', example: 'Use / then Enter to jump.' },
                    { key: '?text', id: 'search-backward', desc: 'Search backward for text', example: 'Use ? then Enter to jump.' },
                    { key: 'n / N', id: 'nN', desc: 'Next / Previous match', example: 'Navigate search results.' },
                ]
            },
            {
                category: 'Other',
                items: [
                    { key: 'u / Ctrl+r', id: 'undo-redo', desc: 'Undo / Redo changes', example: 'Revert or re-apply edits.' },
                    { key: ':q / :wq', id: 'ex', desc: 'Quit / Write & Quit', example: 'Use ex-commands.' },
                ]
            }
        ];

        function renderCheatList(filter = '') {
            const q = filter.trim().toLowerCase();
            cheatContent.innerHTML = '';
            commandCatalog.forEach(group => {
                const matchedItems = group.items.filter(it => {
                    if (!q) return true;
                    return it.key.toLowerCase().includes(q) || it.desc.toLowerCase().includes(q);
                });
                if (matchedItems.length === 0) return;
                const section = document.createElement('div');
                section.innerHTML = `<div class="text-blue-300 font-bold mb-2">${group.category}</div>`;
                const list = document.createElement('div');
                list.className = 'grid grid-cols-1 gap-2';
                matchedItems.forEach(it => {
                    const tried = practicedCommands.has(it.id);
                    const card = document.createElement('button');
                    card.className = `text-left bg-gray-900 border ${tried ? 'border-green-600' : 'border-gray-700'} hover:border-yellow-500 rounded-md p-3 flex items-center justify-between`;
                    card.innerHTML = `
                        <div>
                            <div class="text-yellow-300 font-mono">${it.key}</div>
                            <div class="text-gray-300 text-sm">${it.desc}</div>
                            <div class="text-gray-500 text-xs">${it.example}</div>
                        </div>
                        <div class="text-xs ${tried ? 'text-green-400' : 'text-blue-400'}">${tried ? 'Practiced' : 'Practice'}</div>
                    `;
                    card.addEventListener('click', () => startCheatPractice(it));
                    list.appendChild(card);
                });
                section.appendChild(list);
                cheatContent.appendChild(section);
            });
        }

        function openCheat() {
            cheatOverlay.classList.remove('hidden');
            cheatPanel.classList.remove('translate-x-full');
            cheatSearch.value = '';
            renderCheatList('');
            cheatSearch.focus();
        }
        function closeCheat() {
            cheatOverlay.classList.add('hidden');
            cheatPanel.classList.add('translate-x-full');
            editorInput.focus();
        }

        function startCheatPractice(item) {
            // Minimal practice: load a tiny buffer and set expectations based on command id
            // Save current level context
            const returnLevel = currentLevel;
            const practiceLevels = {
                'hjkL': {
                    instructions: "Practice moving to '$' using h/j/k/l.",
                    initialContent: ["move to the $"], target: { row: 0, col: 12 }
                },
                'wbe': {
                    instructions: "Use w to jump to 'target'.", initialContent: ["one two three target"], target: { row: 0, col: 14 }
                },
                'ggG': {
                    instructions: "Press G to go to last line.", initialContent: ["a","b","c"], target: { row: 2, col: 0 }
                },
                '0$': {
                    instructions: "Press $ to go to end of line.", initialContent: ["line end here"], target: { row: 0, col: 12 }
                },
                'ia': {
                    instructions: "Press a then type ! then Esc.", initialContent: ["Hello"], targetText: { line: 0, text: "Hello!" }
                },
                'x': {
                    instructions: "Delete the x.", initialContent: ["ax"], targetText: { line: 0, text: "a" }
                },
                'dd': {
                    instructions: "Delete the only line (buffer remains with empty line).", initialContent: ["remove me"], targetContent: [""]
                },
                'dw': {
                    instructions: "Delete 'bad' using dw.", initialContent: ["good bad"], targetText: { line: 0, text: "good " }
                },
                'yyp': {
                    instructions: "Yank then paste the line (yy then p).", initialContent: ["copy"], targetContent: ["copy","copy"]
                },
                'cw': {
                    instructions: "Change 'bad' to 'good'.", initialContent: ["bad"], targetText: { line: 0, text: "good" }
                },
                'D': {
                    instructions: "Delete to end from cursor.", initialContent: ["keep remove"], setup: () => { cursor = { row:0, col: 5 }; }, targetText: { line:0, text: "keep " }
                },
                'r': {
                    instructions: "Replace x with ! using r.", initialContent: ["x"], targetText: { line:0, text: "!" }
                },
                'search-forward': {
                    instructions: "Search /target Enter to jump to it.", initialContent: ["find target"], target: { row:0, col:5 }
                },
                'search-backward': {
                    instructions: "Search ?alpha Enter to jump back.", initialContent: ["alpha","beta alpha"], setup: () => { cursor = { row:1, col: 4 }; }, target: { row:0, col:0 }
                },
                'nN': {
                    instructions: "Search /foo then press n to reach the next.", initialContent: ["foo","bar foo"], target: { row:1, col:4 }
                },
                'undo-redo': {
                    instructions: "Delete line with dd, undo with u, redo with Ctrl+r.", initialContent: ["x","y"], targetContent: ["y"], setup: () => { cursor={row:0,col:0}; }
                },
                'ex': {
                    instructions: "Type :q then Enter.", initialContent: ["exit lesson"], exCommands: ["q"], setup: () => { cursor={row:0,col:0}; }
                }
            };
            const pl = practiceLevels[item.id];
            if (!pl) return;
            closeCheat();
            // Inject a temporary level definition at the end and load it
            levels.push({
                name: `Practice: ${item.key}`,
                instructions: pl.instructions,
                initialContent: pl.initialContent,
                target: pl.target,
                targetText: pl.targetText,
                targetContent: pl.targetContent,
                exCommands: pl.exCommands,
                setup: pl.setup || (() => { cursor = { row:0, col:0 }; })
            });
            const practiceIndex = levels.length - 1;
            loadLevel(practiceIndex);
            // Hook into completion to return after win
            const originalShowModal = showModal;
            showModal = function() {
                // mark practiced
                practicedCommands.add(item.id);
                renderCheatList(cheatSearch.value);
                // restore and remove practice level, then return to previous level
                levels.pop();
                showModal = originalShowModal;
                currentLevel = returnLevel;
                loadLevel(currentLevel);
                openCheat();
            };
        }

        function showBadgeToast(message) {
            badgeToast.textContent = message;
            badgeToast.classList.remove('hidden');
            setTimeout(() => badgeToast.classList.add('hidden'), 2200);
        }

        function maybeAwardBadges() {
            // Beginner: after finishing levels up to basic movement group (1-3)
            if (!badges.has('beginner') && currentLevel >= 2) {
                badges.add('beginner');
                renderBadges();
                showBadgeToast('üü¢ Beginner Badge earned!');
            }
            // Search Master: after completing any of the search levels while using search
            const searchNames = ['Search Forward (/)','Search Backward (?)','Search Navigation (n/N)'];
            if (!badges.has('searchmaster') && searchNames.includes(levels[currentLevel].name) && usedSearchInLevel) {
                badges.add('searchmaster');
                renderBadges();
                showBadgeToast('üîé Search Master Badge earned!');
            }
        }

        function renderCommandLog() {
            commandLogEl.textContent = commandLog.slice(-10).join('');
        }

        // --- GAME LOGIC ---
        function checkWinCondition() {
            const level = levels[currentLevel];
            let won = false;
            
            if (level.exCommands) {
                if (lastExCommand && level.exCommands.includes(lastExCommand)) won = true;
            } else if (level.target) {
                // For search-focused levels, require actual search usage
                const searchLevelNames = ['Search Forward (/)','Search Backward (?)','Search Navigation (n/N)'];
                const isSearchLevel = searchLevelNames.includes(level.name);
                if (cursor.row === level.target.row && cursor.col === level.target.col) {
                    if (!isSearchLevel) {
                        won = true;
                    } else {
                        if (level.name === 'Search Navigation (n/N)') {
                            // Require at least two 'n' presses after search to reach 3rd occurrence
                            if (usedSearchInLevel && navCountSinceSearch >= 2 && lastSearchQuery && lastSearchQuery.toLowerCase() === 'foo' && lastSearchDirection === 'forward') won = true;
                        } else if (level.name === 'Search Forward (/)') {
                            // Now require one 'n' after search to reach second occurrence
                            if (usedSearchInLevel && lastSearchDirection === 'forward' && lastSearchQuery && lastSearchQuery.toLowerCase() === 'target' && navCountSinceSearch >= 1) {
                                won = true;
                            }
                        } else if (level.name === 'Search Backward (?)') {
                            // Require one 'N' after search to reach previous occurrence
                            if (usedSearchInLevel && lastSearchDirection === 'backward' && lastSearchQuery && lastSearchQuery.toLowerCase() === 'alpha' && navCountSinceSearch >= 1) {
                                won = true;
                            }
                        }
                    }
                }
            
            } else if (level.targetText) {
                if (content[level.targetText.line] === level.targetText.text && mode === 'NORMAL') won = true;
            
            } else if (level.targetContent) {
                // Compare lines after trimming trailing whitespace and ignoring trailing blank lines
                const trimLineEnd = (line) => line.replace(/\s+$/, '');
                const stripTrailingBlankLines = (lines) => {
                    const result = [...lines];
                    while (result.length > 0 && trimLineEnd(result[result.length - 1]) === '') {
                        result.pop();
                    }
                    return result;
                };
                const currentLines = stripTrailingBlankLines(content.map(trimLineEnd));
                const targetLines = stripTrailingBlankLines(level.targetContent.map(trimLineEnd));
                if (currentLines.length === targetLines.length && currentLines.every((l, i) => l === targetLines[i])) {
                    if (level.name === 'Undo / Redo') {
                        if (level12RedoAfterUndo) won = true;
                    } 
                    else if (level.name === 'Practice: u / Ctrl+r'){
                        if (cheatModeOtherUndo && cheatModeOtherRedoAfterUndo) won = true;
                    }
                    else {
                        won = true;
                    }
                }
            }

            if (won) {
                editorContainer.classList.add('level-complete-flash');
                setTimeout(() => {
                    maybeAwardBadges();
                    showModal();
                    editorContainer.classList.remove('level-complete-flash');
                }, 500);
            }
        }

        function showModal() {
            if (currentLevel === levels.length - 1) {
                showCelebration();
                return;
            }
            modalTitle.textContent = `Level ${currentLevel + 1} Complete!`;
            modalMessage.textContent = `You've mastered: ${levels[currentLevel].name}.`;
            nextLevelBtn.textContent = "Next Level";
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modalContent.classList.remove('scale-95');

            // Allow advancing with Enter key while modal is visible
            const handleEnterAdvance = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Advance level same as clicking next
                    if (currentLevel === levels.length - 1) {
                        currentLevel = 0;
                    } else {
                        currentLevel++;
                    }
                    loadLevel(currentLevel);
                    hideModal();
                    editorInput.focus();
                    window.removeEventListener('keydown', handleEnterAdvance, true);
                }
            };
            // Use capture to ensure we catch it even if focus is elsewhere
            window.addEventListener('keydown', handleEnterAdvance, true);
        }
        
        function hideModal() {
            modal.classList.add('opacity-0', 'pointer-events-none');
            modalContent.classList.add('scale-95');
        }

        // Celebration helpers
        function spawnConfettiOnce() {
            // clear previous
            celebration.querySelectorAll('.confetti').forEach(n => n.remove());
            const emojis = ['üéâ','‚ú®','üéä','‚≠ê','üí•','üî•'];
            const pieces = 60;
            for (let i = 0; i < pieces; i++) {
                const span = document.createElement('span');
                span.className = 'confetti';
                span.textContent = emojis[i % emojis.length];
                span.style.left = Math.random() * 100 + 'vw';
                span.style.animationDuration = (5 + Math.random() * 3).toFixed(2) + 's';
                span.style.animationDelay = (Math.random() * 1.5).toFixed(2) + 's';
                span.style.transform = `translateY(${Math.random()*-40}vh)`;
                celebration.appendChild(span);
            }
        }

        function showCelebration() {
            celebration.classList.remove('hidden');
            // force layout to center on current viewport
            celebration.style.left = '0';
            celebration.style.top = '0';
            celebration.style.right = '0';
            celebration.style.bottom = '0';
            spawnConfettiOnce();
            const handleEnterRestart = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    restartFromCelebration();
                    window.removeEventListener('keydown', handleEnterRestart, true);
                }
            };
            window.addEventListener('keydown', handleEnterRestart, true);
        }

        function hideCelebration() {
            celebration.classList.add('hidden');
            celebration.style.left = '';
            celebration.style.top = '';
            celebration.style.right = '';
            celebration.style.bottom = '';
            celebration.querySelectorAll('.confetti').forEach(n => n.remove());
        }

        function restartFromCelebration() {
            currentLevel = 0;
            loadLevel(currentLevel);
            hideCelebration();
            editorInput.focus();
        }

        function createLevelButtons() {
            levelSelectionContainer.innerHTML = ''; // Clear existing buttons
            levels.forEach((level, index) => {
                const button = document.createElement('button');
                button.textContent = `${index + 1}`;
                button.dataset.level = index;
                button.className = `w-8 h-8 flex items-center justify-center rounded-md transition-colors font-bold`;
                if (index === currentLevel) {
                    button.classList.add('bg-yellow-400', 'text-gray-900');
                } else {
                    button.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                }
                levelSelectionContainer.appendChild(button);
            });
        }

        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            if (levelIndex >= levels.length) {
                currentLevel = 0;
            }
            const level = levels[currentLevel];
            content = [...level.initialContent];
            instructionsEl.textContent = level.instructions;
            levelIndicator.textContent = `Level: ${currentLevel + 1} / ${levels.length}`;
            level.setup();
            mode = 'NORMAL';
            commandHistory = '';
            commandLog = [];
            yankedLine = null;
            level12Undo = false;
            level12RedoAfterUndo = false;
            lastExCommand = null;
            usedSearchInLevel = false;
            searchMode = false;
            searchQuery = '';
            lastSearchQuery = null;
            lastSearchDirection = 'forward';
            searchMatches = [];
            currentMatchIndex = -1;
            navCountSinceSearch = 0;
            updateStatusBar();
            renderCommandLog();
            renderEditor();
            createLevelButtons();
            renderBadges();
        }

        // --- INPUT HANDLING ---
        function handleNormalMode(e) {
            e.preventDefault();
            const key = e.key;
            const isWordChar = (char) => /\w/.test(char);
            // Enter search mode
            if (key === '/' || key === '?') {
                searchMode = true;
                searchQuery = '';
                lastSearchDirection = key === '?' ? 'backward' : 'forward';
                mode = 'NORMAL';
                updateStatusBar();
                return;
            }

            // n / N navigation for last search
            if ((key === 'n' || key === 'N') && lastSearchQuery) {
                const forward = (key === 'n') ? (lastSearchDirection === 'forward') : (lastSearchDirection === 'backward');
                if (searchMatches.length === 0) {
                    updateStatusBar();
                    return;
                }
                if (currentMatchIndex === -1) currentMatchIndex = 0;
                if (forward) {
                    currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
                } else {
                    currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
                }
                const m = searchMatches[currentMatchIndex];
                cursor.row = m.row;
                cursor.col = Math.max(0, m.start);
                navCountSinceSearch++;
                updateStatusBar();
                renderEditor();
                checkWinCondition();
                return;
            }

            // Redo (Ctrl+r) should be handled before any other 'r' logic
            if (key === 'r' && e.ctrlKey) {
                const next = redoStack.pop();
                if (next) {
                    undoStack.push(cloneState());
                    content = [...next.content];
                    cursor = { ...next.cursor };
                    mode = next.mode;
                    yankedLine = next.yankedLine;
                }
                if (levels[currentLevel].name === 'Undo / Redo' && level12Undo) {
                    level12RedoAfterUndo = true;
                }
                if(levels[currentLevel].name === 'Practice: u / Ctrl+r') {
                    cheatModeOtherRedoAfterUndo = true;
                }
                renderEditor();
                checkWinCondition();
                return;
            }

            // Handle Ex commands on Enter: parse from last ':'
            if (key === 'Enter') {
                const idx = commandHistory.lastIndexOf(':');
                if (idx !== -1) {
                    const cmd = commandHistory.slice(idx + 1).trim();
                    lastExCommand = cmd;
                }
                commandHistory = '';
                commandLog = [];
                renderCommandLog();
                checkWinCondition();
                return;
            }

            // Start single-char replace immediately so it doesn't get logged in command history
            if (key === 'r' && !replacePending) {
                replacePending = true;
                commandLog = [];
                return;
            }

            // Handle pending single-char replace (r)
            if (replacePending) {
                // Ignore modifier keys while waiting for the actual replacement character
                if (key === 'Shift' || key === 'Control' || key === 'Alt' || key === 'Meta') {
                    return;
                }
                // Allow cancel with Escape
                if (isEscapeKey(e)) {
                    replacePending = false;
                    renderEditor();
                    return;
                }
                if (key.length === 1) {
                    let line = content[cursor.row];
                    if (cursor.col < line.length) {
                        content[cursor.row] = line.slice(0, cursor.col) + key + line.slice(cursor.col + 1);
                    } else {
                        // If at end, append
                        content[cursor.row] = line + key;
                    }
                    replacePending = false;
                    renderEditor();
                    checkWinCondition();
                    return;
                }
                // For other non-printable keys, do nothing but keep waiting
                return;
            }

            // Handle counts
            if (/^[0-9]$/.test(key)) {
                if (!(key === '0' && countBuffer === '')) {
                    countBuffer += key;
                    commandLog.push(key);
                    renderCommandLog();
                    return;
                }
            }
            if (key.length === 1 && key !== 'Shift' && key !== 'Control' && key !== 'Alt') {
                commandLog.push(key);
                commandHistory += key;
                renderCommandLog();
            }

            // Movement
            const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
            const repeat = (n, fn) => { for (let i = 0; i < n; i++) fn(i); };
            if (key === 'h') repeat(count, () => { if (cursor.col > 0) cursor.col--; });
            if (key === 'l') repeat(count, () => { if (cursor.col < content[cursor.row].length - 1) cursor.col++; });
            if (key === 'k') repeat(count, () => { if (cursor.row > 0) cursor.row--; });
            if (key === 'j') repeat(count, () => { if (cursor.row < content.length - 1) cursor.row++; });
            if (key === '0') { cursor.col = 0; }
            if (key === '$') { const line = content[cursor.row]; cursor.col = Math.max(0, line.length - 1); }

            // Word movement
            // Avoid moving on 'w' when it's part of operators like 'dw' or 'cw'
            if (key === 'w' && !(commandHistory.endsWith('dw') || commandHistory.endsWith('cw'))) {
                repeat(count, () => {
                    const line = content[cursor.row];
                    const match = line.substring(cursor.col).match(/\s\S/);
                    if (match) {
                        cursor.col += match.index + 1;
                    } else if (cursor.row < content.length - 1) {
                        cursor.row++;
                        cursor.col = 0;
                    }
                });
            }
            if (key === 'b') {
                repeat(count, () => {
                    const line = content[cursor.row];
                    const sub = line.substring(0, cursor.col).trimEnd();
                    const lastSpace = sub.lastIndexOf(' ');
                    cursor.col = lastSpace !== -1 ? lastSpace + 1 : 0;
                });
            }
            if (key === 'e') {
                repeat(count, () => {
                    const line = content[cursor.row];
                    let i = cursor.col;
                    if (i < line.length - 1) { i++; }
                    while (i < line.length && !isWordChar(line[i])) { i++; }
                    while (i < line.length - 1 && isWordChar(line[i + 1])) { i++; }
                    if (isWordChar(line[i])) { cursor.col = i; }
                });
            }

            // Line jumps
            if (commandHistory.endsWith('gg')) {
                cursor.row = 0;
                cursor.col = 0;
                commandHistory = ''; commandLog = [];
            }
            if (key === 'G') {
                if (countBuffer) {
                    const lineNum = Math.max(1, parseInt(countBuffer, 10));
                    cursor.row = Math.min(content.length - 1, lineNum - 1);
                    cursor.col = 0;
                } else {
                    cursor.row = content.length - 1;
                    cursor.col = 0;
                }
            }

            // Mode change
            if (key === 'i') {
                mode = 'INSERT';
                commandLog = [];
            }
            if (key === 'a') {
                pushUndo();
                const line = content[cursor.row];
                if (cursor.col < line.length) cursor.col++;
                mode = 'INSERT';
                commandLog = [];
            }
            if (key === 'o') {
                pushUndo();
                cursor.row++;
                content.splice(cursor.row, 0, "");
                cursor.col = 0;
                mode = 'INSERT';
                commandLog = [];
            }
            if (key === 'O') {
                pushUndo();
                content.splice(cursor.row, 0, "");
                cursor.col = 0;
                mode = 'INSERT';
                commandLog = [];
            }
            
            // Deletion
            if (key === 'x') {
                pushUndo();
                const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
                for (let i = 0; i < count; i++) {
                    let line = content[cursor.row];
                    if (cursor.col < line.length) {
                        content[cursor.row] = line.slice(0, cursor.col) + line.slice(cursor.col + 1);
                    }
                }
            }
            if (commandHistory.endsWith('dw')) {
                pushUndo();
                const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
                for (let i = 0; i < count; i++) {
                    let line = content[cursor.row];
                    let start = cursor.col;
                    let endOfWord = line.substring(start).search(/\s|$/);
                    if (endOfWord === -1) { endOfWord = line.length; } else { endOfWord += start; }
                    let startOfNextWord = line.substring(endOfWord).search(/\S/);
                    if (startOfNextWord === -1) { startOfNextWord = line.length; } else { startOfNextWord += endOfWord; }
                    content[cursor.row] = line.slice(0, start) + line.slice(startOfNextWord);
                }
                commandHistory = ''; commandLog = [];
            }
            if (commandHistory.endsWith('cw')) {
                pushUndo();
                // Change word: delete to end of current word and enter insert mode
                let line = content[cursor.row];
                let start = cursor.col;
                let endRel = line.substring(start).search(/\s|$/);
                let end = endRel === -1 ? line.length : start + endRel;
                content[cursor.row] = line.slice(0, start) + line.slice(end);
                mode = 'INSERT';
                commandHistory = ''; commandLog = [];
            }
            if (key === 'D') {
                // Delete to end of line
                pushUndo();
                let line = content[cursor.row];
                content[cursor.row] = line.slice(0, cursor.col);
                commandLog = [];
            }
            // 'r' handled above
            if (commandHistory.endsWith('dd')) {
                pushUndo();
                const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
                for (let i = 0; i < count; i++) {
                    yankedLine = content.splice(cursor.row, 1)[0];
                    if (content.length === 0) content.push("");
                    if (cursor.row >= content.length) cursor.row = content.length - 1;
                }
                cursor.col = 0;
                commandHistory = ''; commandLog = [];
            }
            
            // Yank & Put
            if (commandHistory.endsWith('yy')) {
                const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
                yankedLine = content[Math.min(content.length - 1, cursor.row + count - 1)];
                commandHistory = ''; commandLog = [];
            }
            if (key === 'p' && yankedLine !== null) {
                pushUndo();
                const count = countBuffer ? Math.max(1, parseInt(countBuffer, 10)) : 1;
                for (let i = 0; i < count; i++) {
                    content.splice(cursor.row + 1, 0, yankedLine);
                }
            }

            // Clear operator combos when standalone keys are pressed

            if (['h','j','k','l','w','b','e','G','i','a','o','O','x','p','0','$','D'].includes(key)) {
                commandLog = [];
            }

            // Undo / Redo
            if (key === 'u') {
                const prev = undoStack.pop();
                if (prev) {
                    redoStack.push(cloneState());
                    content = [...prev.content];
                    cursor = { ...prev.cursor };
                    mode = prev.mode;
                    yankedLine = prev.yankedLine;
                }
                if (levels[currentLevel].name === 'Undo / Redo') {
                    level12Undo = true;
                    level12RedoAfterUndo = false;
                }
                if(levels[currentLevel].name === 'Practice: u / Ctrl+r') {
                    cheatModeOtherUndo = true;
                    cheatModeOtherRedoAfterUndo = false;
                }
                renderEditor();
                checkWinCondition();
                return;
            }

            // Reset count when a non-digit key processed
            if (!/^[0-9]$/.test(key)) countBuffer = '';

            // Ensure cursor is within bounds
            if (cursor.row >= content.length) cursor.row = content.length - 1;
            if (cursor.col > content[cursor.row].length) cursor.col = content[cursor.row].length;
            if (cursor.col < 0) cursor.col = 0;
            if(mode === 'NORMAL' && cursor.col === content[cursor.row].length && content[cursor.row].length > 0) {
                cursor.col--;
            }

            updateStatusBar();
            renderEditor();
            if (mode === 'NORMAL') checkWinCondition();
        }

        function recomputeSearchMatches() {
            searchMatches = [];
            if (!lastSearchQuery || lastSearchQuery.length === 0) return;
            const needle = lastSearchQuery.toLowerCase();
            for (let r = 0; r < content.length; r++) {
                const line = content[r];
                const lineLower = line.toLowerCase();
                let idx = 0;
                while (true) {
                    const found = lineLower.indexOf(needle, idx);
                    if (found === -1) break;
                    searchMatches.push({ row: r, start: found, end: found + needle.length });
                    idx = found + (needle.length > 0 ? Math.max(1, needle.length) : 1);
                }
            }
        }

        function jumpToFirstMatchFromCursor() {
            if (searchMatches.length === 0) { currentMatchIndex = -1; return; }
            const startRow = cursor.row;
            const startCol = cursor.col;
            let bestIndex = -1;
            if (lastSearchDirection === 'forward') {
                // first match at or after cursor position scanning forward through lines
                for (let i = 0; i < searchMatches.length; i++) {
                    const m = searchMatches[i];
                    if (m.row < startRow) continue;
                    if (m.row === startRow && m.start < startCol) continue;
                    bestIndex = i; break;
                }
                if (bestIndex === -1) bestIndex = 0; // wrap
            } else {
                // first match at or before cursor scanning backward
                for (let i = searchMatches.length - 1; i >= 0; i--) {
                    const m = searchMatches[i];
                    if (m.row > startRow) continue;
                    if (m.row === startRow && m.start > startCol) continue;
                    bestIndex = i; break;
                }
                if (bestIndex === -1) bestIndex = searchMatches.length - 1; // wrap
            }
            currentMatchIndex = bestIndex;
            const m = searchMatches[currentMatchIndex];
            cursor.row = m.row;
            cursor.col = Math.max(0, m.start);
        }

        function handleSearchMode(e) {
            e.preventDefault();
            const key = e.key;
            if (isEscapeKey(e)) {
                searchMode = false;
                searchQuery = '';
                updateStatusBar();
                return;
            }
            if (key === 'Backspace') {
                searchQuery = searchQuery.slice(0, -1);
                updateStatusBar();
                return;
            }
            if (key === 'Enter') {
                lastSearchQuery = searchQuery;
                usedSearchInLevel = true;
                searchMode = false;
                currentMatchIndex = -1;
                recomputeSearchMatches();
                jumpToFirstMatchFromCursor();
                navCountSinceSearch = 0;
                updateStatusBar();
                renderEditor();
                checkWinCondition();
                return;
            }
            if (key.length === 1) {
                searchQuery += key;
                updateStatusBar();
            }
        }

        function handleInsertMode(e) {
            e.preventDefault();
            let line = content[cursor.row];
            if (isEscapeKey(e)) {
                mode = 'NORMAL';
                if (cursor.col > 0) cursor.col--;
            } else if (e.key === 'Backspace') {
                if (cursor.col > 0) {
                    content[cursor.row] = line.slice(0, cursor.col - 1) + line.slice(cursor.col);
                    cursor.col--;
                }
            } else if (e.key.length === 1) {
                content[cursor.row] = line.slice(0, cursor.col) + e.key + line.slice(cursor.col);
                cursor.col++;
            }
            updateStatusBar();
            renderEditor();
            if (mode === 'NORMAL') checkWinCondition();
        }

        // --- EVENT LISTENERS ---
        editorInput.addEventListener('keydown', (e) => {
            if (searchMode) {
                handleSearchMode(e);
                return;
            }
            if (mode === 'NORMAL') {
                handleNormalMode(e);
            } else {
                handleInsertMode(e);
            }
        });

        editorContainer.addEventListener('click', () => editorInput.focus());
        
        nextLevelBtn.addEventListener('click', () => {
            if (currentLevel === levels.length - 1) {
                showCelebration();
            } else {
                currentLevel++;
                loadLevel(currentLevel);
                hideModal();
                editorInput.focus();
            }
        });

        celebrationRestartBtn.addEventListener('click', restartFromCelebration);

        resetBtn.addEventListener('click', () => {
            loadLevel(currentLevel);
            editorInput.focus();
        });

        levelSelectionContainer.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const levelIndex = parseInt(e.target.dataset.level, 10);
                if (levelIndex !== currentLevel) {
                    loadLevel(levelIndex);
                }
                editorInput.focus();
            }
        });

        // Ensure Ctrl+R redo is not swallowed by browser reload even if focus drifts
        window.addEventListener('keydown', (e) => {
            if (mode === 'NORMAL' && e.key === 'r' && e.ctrlKey) {
                e.preventDefault();
                handleNormalMode(e);
            }
            // Toggle Cheat Mode with Ctrl+/
            if (e.ctrlKey && e.key === '/') {
                e.preventDefault();
                if (cheatPanel.classList.contains('translate-x-full')) {
                    openCheat();
                } else {
                    closeCheat();
                }
            }
        }, true);

        challengeToggleBtn.addEventListener('click', () => {
            challengeMode = !challengeMode;
            if (challengeMode) {
                challengeContainer.classList.remove('hidden');
                startChallenge();
            } else {
                challengeContainer.classList.add('hidden');
                // If in challenge mode, return to current level
                loadLevel(currentLevel);
                editorInput.focus();
            }
        });

        // Cheat panel controls
        document.getElementById('challenge-toggle').insertAdjacentHTML('afterend', '<button id="cheat-toggle" class="ml-3 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">üìò Cheat Mode</button>');
        const cheatToggleBtn = document.getElementById('cheat-toggle');
        cheatToggleBtn.addEventListener('click', () => {
            if (cheatPanel.classList.contains('translate-x-full')) openCheat(); else closeCheat();
        });
        cheatOverlay.addEventListener('click', closeCheat);
        cheatCloseBtn.addEventListener('click', closeCheat);
        cheatSearch.addEventListener('input', (e) => renderCheatList(e.target.value));

        // --- INITIAL LOAD ---
        loadLevel(currentLevel);
        editorInput.focus();

        // --- CHALLENGE FUNCTIONS ---

        // --- DEV TESTING UTILITIES ---
        // Simple input simulation to verify Ctrl-[ behaves like Escape
        window.simulateEscapeEquivalence = () => {
            // Prepare a tiny scenario: enter insert, type 'x', then exit with Esc and with Ctrl-[ and compare states
            const snapshotState = () => ({
                content: [...content],
                cursor: { ...cursor },
                mode
            });

            // Baseline: reset level and go to insert
            const original = cloneState();
            mode = 'INSERT';
            const beforeEsc = snapshotState();
            // Simulate Escape
            handleInsertMode({ key: 'Escape', preventDefault: () => {} });
            const afterEsc = snapshotState();

            // Restore and simulate Ctrl-[
            content = [...original.content];
            cursor = { ...original.cursor };
            mode = 'INSERT';
            const beforeCtrl = snapshotState();
            handleInsertMode({ key: '[', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false, preventDefault: () => {} });
            const afterCtrl = snapshotState();

            return {
                beforeEsc,
                afterEsc,
                beforeCtrl,
                afterCtrl,
                equal: JSON.stringify(afterEsc) === JSON.stringify(afterCtrl)
            };
        };
        function startChallenge() {
            if (currentChallenge) return;
            
            // Select a random challenge
            const challengeIndex = Math.floor(Math.random() * challenges.length);
            currentChallenge = challenges[challengeIndex];
            currentTaskIndex = 0;
            challengeScoreValue = 0;
            challengeProgressValue = 0;
            challengeStartTime = Date.now();
            
            // Update UI
            challengeInstructions.textContent = `${currentChallenge.description} (Editor is focused - commands ready!)`;
            challengeTotal.textContent = currentChallenge.tasks.length;
            challengeProgress.textContent = '0';
            challengeScore.textContent = '0';
            
            // Load challenge content
            content = [...currentChallenge.initialContent];
            cursor = { row: 0, col: 0 };
            mode = 'NORMAL';
            renderEditor();
            
            // Start timer
            const timeLeft = currentChallenge.timeLimit;
            challengeTimer.textContent = `${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;
            
            challengeTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - challengeStartTime) / 1000);
                const remaining = currentChallenge.timeLimit - elapsed;
                
                if (remaining <= 0) {
                    endChallenge(false);
                    return;
                }
                
                const minutes = Math.floor(remaining / 60);
                const seconds = remaining % 60;
                challengeTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
            
            // Show first task
            showCurrentTask();
            
            // Focus the editor so commands work immediately
            editorInput.focus();
        }

        function showCurrentTask() {
            if (!currentChallenge || currentTaskIndex >= currentChallenge.tasks.length) return;
            
            const task = currentChallenge.tasks[currentTaskIndex];
            challengeInstructions.textContent = `Task ${currentTaskIndex + 1}: ${task.instruction}`;
        }

        function checkChallengeTask() {
            if (!currentChallenge || currentTaskIndex >= currentChallenge.tasks.length) return;
            
            const task = currentChallenge.tasks[currentTaskIndex];
            if (task.validation()) {
                // Task completed
                challengeProgressValue++;
                challengeProgress.textContent = challengeProgressValue;
                
                // Calculate score based on time
                const elapsed = Math.floor((Date.now() - challengeStartTime) / 1000);
                const timeBonus = Math.max(0, currentChallenge.timeLimit - elapsed);
                const taskScore = 100 + timeBonus;
                challengeScoreValue += taskScore;
                challengeScore.textContent = challengeScoreValue;
                
                currentTaskIndex++;
                
                if (currentTaskIndex >= currentChallenge.tasks.length) {
                    // All tasks completed
                    endChallenge(true);
                } else {
                    // Show next task
                    showCurrentTask();
                }
            }
        }

        function endChallenge(success) {
            if (challengeTimerInterval) {
                clearInterval(challengeTimerInterval);
                challengeTimerInterval = null;
            }
            
            if (success) {
                const elapsed = Math.floor((Date.now() - challengeStartTime) / 1000);
                const finalScore = challengeScoreValue + Math.max(0, currentChallenge.timeLimit - elapsed) * 10;
                
                alert(`Challenge Complete!\nFinal Score: ${finalScore}\nTime: ${elapsed}s\nGreat job!`);
            } else {
                alert('Time\'s up! Challenge failed. Try again!');
            }
            
            // Reset challenge state
            challengeMode = false;
            currentChallenge = null;
            currentTaskIndex = 0;
            challengeScoreValue = 0;
            challengeProgressValue = 0;
            
            // Hide challenge container
            challengeContainer.classList.add('hidden');
            
            // Return to current level
            loadLevel(currentLevel);
            editorInput.focus();
        }

        // Add challenge task checking to win condition
        const originalCheckWinCondition = checkWinCondition;
        checkWinCondition = function() {
            if (challengeMode && currentChallenge) {
                checkChallengeTask();
            }
            return originalCheckWinCondition.call(this);
        };
    </script>
</body>
</html>
